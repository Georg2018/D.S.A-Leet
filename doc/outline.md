
# Basic Data Structure Operations
![ADT](img/ADT.jpg)
常用的数据结构一般有数组、单链表、栈、队列、树、哈希表、图等。这是按照数据结构的定义来划分的，一般关于数据结构的书上都是这么划分的。但是实际应用中，例如STL中封装的数据结构种类远不止这么多，而它们的底层实现却无外乎上述几种结构。这里按照STL中的结构将抽象数据结构分为stack、queue、set和map四种结构。

* stack和queue都可以分别基于数组和链表实现。但实际应用中，stack常用于一些特殊模式的存储，和数组一样，按照先后顺序存储元素即可，对数据结构本身并没有太多操作，所以这里将其归为一类。
* linked-list（单链表）在实际应用中主要用于那些插入删除频繁的数据结构，考察点也主要是单链表的基本操作。由于单链表不能随机访问，只能按照插入顺序逐个访问元素，这个过程就类似于队列的特性。而priority-queue作为queue的一种变形，能够按照特定的要求输出元素（按大小顺序等），其内部除了存储元素之外，还要维护一些额外的信息来实现该功能，一般由堆（也即树）来实现。
* set和map常用于查询某个数据是否存在，如果追求查询效率，则用哈希表来存储，查询时间复杂度为O(1)；而用红黑树来存储，查询复杂度为O(log n)，但是内部元素是排好序的，可以整体按序输出。

其实从内存的角度来看，所有的数据结构都可以归为链表，这里的链表并不等同于单链表。数据结构的形式变化再大，在内存中的每个结点无外乎要存储当前节点的值和后续节点的位置指针这两种元素。而每一种数据结构都可以看作是链表的一种特例，数组可以看作是以连续位置代替位置指针；后续指针为一个时就是单链表，为多个时就是树；后续指针又再次指向前序结点时就构成了图；而以数组和单链表为基础又可以根据不同功能来构建栈、队列与哈希表等结构。所以当你能够从一个计算机的角度来看待时，你就能够认识到这些数据结构都是统一的。

----------------------------------------------
## vector

__41.first missing positive__
* 哈希表查找

solution 1
该题的一般解法是先对数组进行排序，再从正整数部分开始遍历，查找到第一个不连续的值就可以。时间复杂度为O(nlogn)，主要是排序的时间复杂度。

solution 2
第二种方法就根据题目的特性，数组中有n个元素，最理想的情况就是n个元素都是连续正整数，这样输出n，否则的话输出的数会小于n（考虑有负数和大的不连续的数的情况）。所以该方法首先将数组中的元素都存入哈希表，然后遍历数字1~n，查询当前数字是否在哈希表中，如不存在，则输出当前数；若都存在，则输出n。


__k sum__
* 两边夹逼
时间复杂度最低为O(n^(k-1))
空间复杂度最低为O(1)

solution 1
k层循环逐个数遍历 O(n^k)

solution 2
1.  数组元素存入哈希表
2.  k-1层遍历，k-1个数加起来作为当前target
3.  从哈希表查询target是否存在

time: O(n^(k-1))
space: O(n)

solution3

k>=3时 
1.  先sort数组 O(nlogn)
2.  k-2层循环枚举，k-2个数加起来作为当前target
3.  剩下n-k+1个元素两边夹逼，两个指针首尾遍历O(n)

time:O(n^(k-1))
space:O(1)

__k=2时就退化为solution 2__


__20.valid parentheses__
* stack应用

## linked-list
__21.Recover Binary Search Tree__
----------------------------------------------
## priority_queue
__239.sliding window maximum__

__480.sliding window median__

solution 1
基本方法：两层循环 O(n*k)

solution 2
通用方法
1.  最外层循环 O(n)
2.  用priority queue来维护这个window，最优情况下存取复杂度都为O(1)，但是不是最优时可能会退化为O(log n)
3.  每次priority queue输出最大值即可

__此方法的通用性在于priority queue的强大，可以适用于各种情况。比如求最大值，最小值，或者中值，或者第k大的数，都可以用priority queue来实现__


solution 3 特殊方法
deque
1.  最外层循环 O(n)
2.  用deque来维护这个window，deque中存储元素下标，这里deque的大小不固定，不像priority queue一样固定为k

```cpp
← deque  →
[1  3  -1] -3  5  3  6  7
↑       ↑
front   back

//1.窗口移动时，弹出最左边元素（如果该元素仍在窗口有效范围内，则保留
if(deque.front <= i-k)       deque.pop_front();
//2.从窗口右端开始逐个与当前数nums[i]比较，小于nums[i]的数都弹出队列
while(nums[deque.back] < nums[i])     deque.pop_back();
//3.nums[i]插入队列，这样可以保证deque中的数是按照从大到小排列
//每次遍历nums[i]时，队列中比它小的数都会被删除
//这样队首总是窗口内的最大值
deque.push_back(i);
//4.输出最大值
res.push_back(nums[deque.front()]);
```
time: O(n)


__23.Merge k Sorted Lists__讲解一下